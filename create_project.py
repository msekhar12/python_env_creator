import argparse
import os
import sys

'''
To execute use:
create_project.py -n <name of the project> \
                  -l <location else defaults to current dir> \
                  -r <optional requirements file> \


This script will create a virtual env inside the project location.
If a requirements file is supplied as input using -r option then those packages
are also installed.
pytest package is inbstalled always

If the project folder is already existing, then the script will fail, unless you
supply -o option (to overwrite).

See the examples folder inside the src directory (generated by this script) to
find some example scripts (calculator.py, argparse_example.py).

The script tests/test_calculator.py contains test scripts to test the
calculator.py code.
You can start creating new programs inside the src/programs directory,
and use tests directory to create your test scripts.

To execute your test scripts execute the following command from the test
directory:

pytest
'''


class DirectoryException(Exception):
    '''
    A custom exception
    '''
    pass


def read_arguments():
    '''
    Read the command line arguments
    There can be 4 arguments:
    --name or -n:           Project name
    --location or -l:       Directory location where the project will be created
    --requirements or -r:   Path to your requirements file (optional)
    --overwrite or -o:      If you want to overwrite the existing project folder
                            Default is False

    The function will return the comman line arguments packaged inside args
    object
    '''
    parser = argparse.ArgumentParser(description='Process arguments')
    parser.add_argument('--name', '-n', type=str, required=True,
                        help='Name of the project')
    parser.add_argument('--location', '-l', type=str, required=False,
                        help='Directory or location of the project.'
                        'Defaults to current directory', default='./')

    parser.add_argument('--requirements', '-r', type=str, required=False,
                        help='Requirements file path, if any',
                        default=None)

    parser.add_argument('--overwrite', '-o', action='store_true',
                        help='If supplied overwrites the project directory')

    args = parser.parse_args()

    return args


def print_args():
    args = read_arguments()
    print(args.name)
    print(args.location)
    print(args.requirements)


def create_directories(project_dir):
    '''
    This will be the project structure:
    <project_location>/<project_name>/src/
                                         |--__init__.py
                                         |--programs
                                            |--__init__.py
                                         |--tests
                                            |--__init__.py
                                            |test_calculator.py
                                         |--examples
                                            |--__init__.py
                                            |--argparse_example.py
                                            |--calculator.py
                                         |--exceptions.py
    <project_location>/<project_name>/setup.py
    <project_location>/<project_name>/requirements.txt
    <project_location>/<project_name>/venv

    The directory details are given below:
    <project_location>: Location of the project.
                        Defaults to current working directory
                        (or) --location argument (if supplied)

    <project_name>: Name of the project. --name argument

    src: directory that contains the source code of the project

    programs: This is where your programs will reside

    tests: This is where you will create your pytest cases

    examples: Contains some example python scripts.
              Contains calculator.py and argparse_example.py files

    setup.py: contains the following code:
        from setuptools import setup, find_packages
        setup(name='<project_name>', version='1.0', packages=find_packages())

    requirements.txt: Contains the packages. Usually the copy of the requirements
                      you supply as input along with the pytest module.
                      When you release the project, please generate a new
                      requirements file using the following commands:

                      1. Change directory to parent dir of /<project_location>
                      2. Activate your virtual env
                         source venv/bin/activate
                      3. Execute this command:
                         pip freeze > requirements.txt

    venv: Your virtual environment (will be auto generated)
    '''

    try:
        # Create src directory within project dir:
        os.mkdir(os.path.join(project_dir, 'src'))

        # Create programs directory within project_dir/src:
        os.mkdir(os.path.join(project_dir, 'src/programs'))

        # Create tests directory within project_dir/src:
        os.mkdir(os.path.join(project_dir, 'src/tests'))

        # Create examples directory within project_dir/src:
        os.mkdir(os.path.join(project_dir, 'src/examples'))

        # Create exceptions directory within project_dir/src:
        os.mkdir(os.path.join(project_dir, 'src/exceptions'))
    except:
        print("Exception has occurred while creating the directories")


def create_python_code(project_dir, project_name):
    '''
    Create the following python files:
    1. __init__.py files in the following locations:
            <project_location>/<project_name>/src
            <project_location>/<project_name>/src/programs
            <project_location>/<project_name>/src/tests
            <project_location>/<project_name>/src/examples

    2. setup.py and fill in the code
    3. exceptions.py and fill in the code for TestException
    4. src/examples/calculator.py and fill a sample calculator program
    5. src/examples/argparse_example.py and fill sample code to parse cmd args
    '''

    # Create __init__.py files
    os.system(f"touch {os.path.join(project_dir, 'src/__init__.py')}")
    os.system(f"touch {os.path.join(project_dir, 'src/programs/__init__.py')}")
    os.system(f"touch {os.path.join(project_dir, 'src/tests/__init__.py')}")
    os.system(f"touch {os.path.join(project_dir, 'src/examples/__init__.py')}")
    os.system(f"touch {os.path.join(project_dir, 'src/exceptions/__init__.py')}")

    # Create setup.py file
    with open(os.path.join(project_dir, 'setup.py'), 'w') as f:
        s = f'''from setuptools import setup, find_packages
setup(name = "{project_name}", version = "1.0",
     packages=find_packages())
        '''
        f.write(s)

    # Create a TestException file
    with open(os.path.join(project_dir, 'src/exceptions/exceptions.py'), 'w') as f:
        s = '''class TestException(Exception):
    pass

class CalculatorException(Exception):
    pass
        '''
        f.write(s)

    # Create argparse_example.py code
    with open(os.path.join(project_dir, 'src/examples/argparse_example.py'),
              'w') as f:
        s = """def read_arguments():
    parser = argparse.ArgumentParser(description='Process arguments')
    parser.add_argument('--name', '-n', type=str, required=True,
                        help='Name of the project')
    parser.add_argument('--location', '-l', type=str, required=False,
                        help='Directory or location of the project.'
                        'Defaults to current directory', default='./')

    parser.add_argument('--requirements', '-r', type=str, required=False,
                        help='Requirements file path, if any')

    parser.add_argument('--overwrite', '-o', action='store_true',
                        help='If supplied overwrites the project directory')

    args = parser.parse_args()

    return args
        """
        f.write(s)

    with open(os.path.join(project_dir, 'src/examples/calculator.py'),
              'w') as f:
        s = '''import src.exceptions.exceptions as exceptions
import sys


class Calculator:
    def add(self, a, b):
        a = self._check_numeric(a)
        b = self._check_numeric(b)
        print("in add")
        return a + b

    def subtract(self, a, b):
        a = self._check_numeric(a)
        b = self._check_numeric(b)
        return a - b

    def multiply(self, a, b):
        a = self._check_numeric(a)
        b = self._check_numeric(b)
        return a * b

    def divide(self, a, b):
        a = self._check_numeric(a)
        b = self._check_numeric(b)
        if b == 0:
            raise exceptions.CalculatorException(
                "The denominator cannot be 0 for division"
            )
        else:
            return a / b

    def _check_numeric(self, a):
        try:
            a = float(a)
            return a
        except ValueError:
            raise exceptions.CalculatorException(
                f"The supplied argument {a} is not numeric")


def main():
    c = Calculator()

    operations = [c.add, c.subtract, c.multiply, c.divide]

    for index, operation in enumerate(operations, start=1):
        print(f"{index}. {operation.__name__}")
    print("Enter q or Q for quit")

    choice = None
    while True:
        choice = input("Enter your choice: ")
        if choice not in ('1', '2', '3', '4', 'q', 'Q'):
            print("You must choose one of these choices: 1, 2, 3, 4, q or Q")
            continue
        else:
            if choice == 'q' or choice == 'Q':
                print("Good Bye")
                sys.exit()
            else:
                a = input("Enter a: ")
                b = input("Enter b: ")
                try:
                    result = operations[int(choice) - 1](a, b)
                    print(f"Result: {result}")
                except exceptions.CalculatorException:
                    print("Please enter numeric arguments.")
                    print("For division, the denominator cannot be 0")
                    continue


if __name__ == '__main__':
    main()
'''
        f.write(s)

    with open(os.path.join(project_dir, 'src/tests/test_calculator.py'),
              'w') as f:
        s = '''# If you get any issues while importing the following modules,
# try to deactivate and activate the venv

# To execute the test scripts:
# Change directory to the project folder
# cd <project_folder>
# source venv/bin/activate
# pytest src/tests

# NOTE: you can use the following options while
# executing the pytest:
# -v for verbose
# -s if you want to execute the print statements in the test cases


from src.examples.calculator import Calculator
from src.exceptions import exceptions
import pytest


# Example code to test add function
def test_add():
    c = Calculator()
    assert c.add(1, 3) == 4


# Example code to test exceptions
def test_add_exception():
    c = Calculator()
    with pytest.raises(exceptions.CalculatorException) as context:
        c.add('a', 1)
    assert str(context.value) == 'The supplied argument a is not numeric'


# Run a series of tests on a bunch of inputs
# We need to use a decorator
@pytest.mark.parametrize(
    'a, b, expected', [
        (1, 2, 3),
        (2, 1, 3),
        (30, 40, 70),
        (-10, 10, 0)
    ]
)
def test_with_parms(a, b, expected):
    c = Calculator()
    assert c.add(a, b) == expected

# It is always advisable to group the test cases into different classes,
# based on the functions that you test. For instance, group all the add()
# test cases under the class TestAdd. This way get 2 advantages:
# 1. The code looks organized
# 2. You can confine your pytest execution to a specific class.
# For ex, to execute the test cases in TestAdd class:
# pytest test_calculator.py::TestAdd


class TestAdd:
    @pytest.mark.parametrize(
        'a,b,expected', [(1, 2, 3),
                         (10, 20, 30),
                         (0, 1, 1),
                         (0, -1, -1),
                         (-1, 1, 0),
                         (0, 0, 0),
                         (-2, 1, -1)]
    )
    def test_add(self, a, b, expected):
        c = Calculator()
        assert c.add(a, b) == expected

    # Test exceptions
    @pytest.mark.parametrize('a,b,expected', [
        ('a', 'b', 'The supplied argument a is not numeric'),
        ('a', 1, 'The supplied argument a is not numeric'),
        (1, 'b', 'The supplied argument b is not numeric')
    ])
    def test_add_exceptions(self, a, b, expected):
        c = Calculator()
        with pytest.raises(exceptions.CalculatorException) as context:
            c.add(a, b)

        assert str(context.value) == expected

    # monkeypatch
    # monkeypatch can replace any function in your source code with a different
    # function. For instance, if your code connects to a hive database, then
    # for your test cases, you can just replace that source function in your
    # test program, and generate some fake data.

    # In the following code we will replace the Calculator's add() function to
    # always return 42 value

    def test_add_fixture_demo(self, monkeypatch):
        c = Calculator()

        def fake_add(self, a, b):
            return 42
        monkeypatch.setattr(Calculator, "add", fake_add)
        assert c.add('a', 'b') == 42
        assert c.add(2, 1) == 42
'''
        f.write(s)


def create_project_dir(args):
    project_location = os.path.abspath(args.location)
    project_name = args.name

    project_dir = os.path.join(project_location, project_name)

    if os.path.exists(project_dir):
        if args.overwrite:
            os.system(f'rm -r {project_dir}')
        else:
            raise DirectoryException(f'The project directory {project_dir}'
                                     ' already exists. To overwrite use --overwrite'
                                     ' option')
            sys.exit()

    # Create project directory:
    os.mkdir(project_dir)

    return project_dir


def create_virtual_env(project_dir):
    os.system(f'python3 -m venv {os.path.join(project_dir,"venv")}')


def install_env(project_dir, requirements_path=None):
    # Create a script to run under the virtual env:
    f'''source {os.path.join(project_dir,'/venv/bin/activate')}

pip install pytest
pip install -e {project_dir}    '''

    s = f'''source {os.path.join(project_dir,'venv/bin/activate')}
# Install pytest
pip install pytest

# Install your project
pip install -e {project_dir}

# Create requirements.txt
pip freeze > {os.path.join(project_dir, 'requirements.txt')}

'''
    if requirements_path:
        requirements_path = os.path.abspath(requirements_path)
        s = s + '\n' + f'''pip install -r {requirements_path}'''

    s = s + f'''\n# pytest the code
pytest {os.path.join(project_dir,'src/tests -v')}
'''

    with open(os.path.join(project_dir, 'install.sh'), 'w') as f:
        f.write(s)

    # Change the install.sh as an executable file
    os.system(f'''chmod 770 {os.path.join(project_dir, 'install.sh')}''')

    # Perform installation now!!
    os.system(f'''{os.path.join(project_dir, 'install.sh')}''')


def main():
    # print_args()

    # Read the command line arguments
    args = read_arguments()

    # Get the project directory
    project_dir = create_project_dir(args)

    # Get the project name
    project_name = args.name

    # Create python3 virtual env in the project dir
    create_virtual_env(project_dir)

    # Create the required directories
    create_directories(project_dir)

    # Create required and example python scripts
    create_python_code(project_dir, project_name)

    # Install your project environment in the virtual env
    install_env(project_dir, args.requirements)


if __name__ == '__main__':
    main()
